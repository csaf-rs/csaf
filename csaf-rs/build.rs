use json_dotpath::DotPaths;
use proc_macro2::{Ident, Span};
use quote::quote;
use serde_json::{Value, json};
use std::path::Path;
use std::string::ToString;
use std::{fs, io};
use thiserror::Error;
use typify::{TypeSpace, TypeSpaceSettings};

#[derive(Error, Debug)]
pub enum BuildError {
    #[error("I/O error")]
    IoError(#[from] io::Error),
    #[error("JSON schema error")]
    SchemaError(#[from] typify::Error),
    #[error("Rust syntax error")]
    SyntaxError(#[from] syn::Error),
    #[error("JSON parsing error")]
    JsonError(#[from] serde_json::Error),
    #[error("other error")]
    Other,
}

#[derive(Debug, Clone, Copy)]
enum CsafVersion {
    V2_0,
    V2_1,
}

fn main() -> Result<(), BuildError> {
    println!("cargo:rerun-if-changed=build.rs");

    // All schema files for change watching
    let schema_configs = [
        (
            "assets/csaf_2.0_json_schema.json",
            "csaf2_0/schema.generated.rs",
            Some(&fix_2_0_schema as &dyn Fn(&mut Value)),
        ),
        (
            "assets/csaf_2.1_json_schema.json",
            "csaf2_1/schema.generated.rs",
            Some(&fix_2_1_schema),
        ),
        (
            "assets/decision_point_json_schema.json",
            "csaf2_1/ssvc_dp.generated.rs",
            None,
        ),
        (
            "assets/decision_point_selection_list_json_schema.json",
            "csaf2_1/ssvc_dp_selection_list.generated.rs",
            None,
        ),
    ];

    // Register watching for all inputs
    for (input, _, _) in &schema_configs {
        println!("cargo:rerun-if-changed={}", input);
    }

    // Execute all listed schema builds
    for (input, output, schema_patch) in &schema_configs {
        build(input, output, schema_patch)?;
    }

    generate_language_subtags()?;
    generate_testcases(
        "../csaf/csaf_2.0/test/validator/data/testcases.json",
        "csaf2_0/testcases.generated.rs",
        CsafVersion::V2_0,
    )?;
    generate_testcases(
        "../csaf/csaf_2.1/test/validator/data/testcases.json",
        "csaf2_1/testcases.generated.rs",
        CsafVersion::V2_1,
    )?;

    Ok(())
}

pub static GENERATED_CODE_HEADER: &str = "
 * This file is automatically generated by build.rs.
 * Do not edit manually!
 ";

fn add_ignore_rustfmt(file: &mut syn::File) {
    let doc_attr = syn::parse_quote! { #![cfg_attr(any(), rustfmt::skip)] };
    file.attrs.insert(0, doc_attr);
}

fn add_ignore_clippy(file: &mut syn::File) {
    let doc_attr = syn::parse_quote! { #![allow(clippy::all)] };
    file.attrs.insert(0, doc_attr);
}

fn build(input: &str, output: &str, schema_patch: &Option<&dyn Fn(&mut Value)>) -> Result<(), BuildError> {
    let content = fs::read_to_string(input)?;
    let mut schema_value = serde_json::from_str(&content)?;
    // Execute a schema patch function, if provided.
    if let Some(patch_fn) = schema_patch {
        patch_fn(&mut schema_value);
    }
    let schema: schemars::schema::RootSchema = serde_json::from_value(schema_value)?;

    let mut type_space = TypeSpace::new(
        TypeSpaceSettings::default()
            .with_struct_builder(true)
            .with_derive("PartialEq".into())
            .with_derive("Eq".into()),
    );
    type_space.add_root_schema(schema)?;

    // Convert the TypeSpace token stream into a syn::File so we can inject a file-level doc attribute
    let mut file = syn::parse2::<syn::File>(type_space.to_stream())?;

    add_ignore_rustfmt(&mut file);
    add_ignore_clippy(&mut file);
    // Parse the GENERATED_CODE_HEADER as a doc attribute
    let doc_attr = syn::parse_quote! { #![doc = #GENERATED_CODE_HEADER] };
    file.attrs.insert(0, doc_attr);

    // Unparse the modified syn::File into Rust source code
    let content = prettyplease::unparse(&file);

    let mut out_file = Path::new("src").to_path_buf();
    out_file.push(output);
    Ok(fs::write(out_file, content)?)
}

/// Patches (unsupported) external schemas to the plain object type for CSAF 2.0.
fn fix_2_0_schema(value: &mut Value) {
    let prefix = "properties.vulnerabilities.items.properties.scores.items.properties";
    let fix_paths = [format!("{}.cvss_v2", prefix), format!("{}.cvss_v3", prefix)];
    for path in fix_paths {
        value.dot_set(path.as_str(), json!({"type": "object"})).unwrap();
    }
    remove_datetime_formats(value);
}

/// Patches (unsupported) external schemas to the plain object type for CSAF 2.1.
fn fix_2_1_schema(value: &mut Value) {
    let prefix = "properties.vulnerabilities.items.properties.metrics.items.properties.content.properties";
    let fix_paths = [
        format!("{}.cvss_v2", prefix),
        format!("{}.cvss_v3", prefix),
        format!("{}.cvss_v4", prefix),
        format!("{}.ssvc_v1", prefix),
        format!("{}.ssvc_v2", prefix),
    ];
    for path in fix_paths {
        value.dot_set(path.as_str(), json!({"type": "object"})).unwrap();
    }
    remove_datetime_formats(value);
}

/// Recursively searches for "format": "date-time" and removes this format.
fn remove_datetime_formats(value: &mut Value) {
    if let Value::Object(map) = value {
        if let Some(format) = map.get("format") {
            if format.as_str() == Some("date-time") {
                // Remove the format property entirely
                map.remove("format");
            }
        }

        // Recursively process all values in the object
        for (_, v) in map.iter_mut() {
            remove_datetime_formats(v);
        }
    } else if let Value::Array(arr) = value {
        for item in arr.iter_mut() {
            remove_datetime_formats(item);
        }
    }
}

/// Compile-time-embedded language-subtag-registry.txt
const LANGUAGE_REGISTRY: &str = include_str!("assets/language-subtag-registry.txt");

/// Generates the language subtags array from the build-embedded text file.
fn generate_language_subtags() -> Result<(), BuildError> {
    let mut subtags = Vec::new();
    let mut current_entry_type = None;

    for line in LANGUAGE_REGISTRY.lines() {
        let line = line.trim();

        if line.is_empty() || line.starts_with("%%") {
            current_entry_type = None;
            continue;
        }

        if let Some(type_value) = line.strip_prefix("Type: ") {
            current_entry_type = Some(type_value.to_string());
            continue;
        }

        if let Some(ref entry_type) = current_entry_type {
            if entry_type == "language" {
                if let Some(subtag) = line.strip_prefix("Subtag: ") {
                    subtags.push(subtag.to_lowercase().to_string());
                }
            }
        }
    }

    subtags.sort_unstable();

    let subtags_iter = subtags.iter().map(|s| s.as_str());

    let tokens = quote! {
        #![doc = #GENERATED_CODE_HEADER]
        pub static LANGUAGE_SUBTAGS_ARRAY: &[&str] = &[
            #(#subtags_iter),*
        ];

        /// Checks if a given subtag is a valid language subtag.
        /// Lower cases the input before checking.
        pub fn is_valid_language_subtag(subtag: &str) -> bool {
            let sub = &subtag.to_lowercase();
            LANGUAGE_SUBTAGS_ARRAY.binary_search(&sub.as_str()).is_ok()
        }
    };

    let mut file: syn::File = syn::parse2(tokens)?;
    add_ignore_rustfmt(&mut file);
    add_ignore_clippy(&mut file);

    // Pretty-print the generated code.
    let code = prettyplease::unparse(&file);

    let out_path = Path::new("src").join("generated").join("language_subtags.rs");
    fs::write(&out_path, code)?;

    println!("cargo:rerun-if-changed=../assets/language-subtag-registry.txt");
    Ok(())
}

/// Extract test case number from filename like "oasis_csaf_tc-csaf_2_0-2021-6-1-08-01.json" -> "01"
fn extract_test_case_number(filename: &str) -> Option<String> {
    // Remove path prefix and .json suffix
    let name = filename.split('/').next_back().unwrap_or(filename);
    let name = name.strip_suffix(".json").unwrap_or(name);

    // Get the last component after the last dash
    name.split('-').next_back().map(|s| s.to_string())
}

#[derive(serde::Deserialize)]
struct TestCasesJson {
    tests: Vec<TestCase>,
}

#[derive(serde::Deserialize)]
struct TestCase {
    id: String,
    group: String,
    #[serde(default)]
    failures: Vec<TestDocument>,
    #[serde(default)]
    valid: Vec<TestDocument>,
}

#[derive(serde::Deserialize)]
struct TestDocument {
    name: String,
    #[allow(dead_code)]
    valid: bool,
}

/// Generates testcases module from testcases.json
fn generate_testcases(input: &str, output: &str, csaf_version: CsafVersion) -> Result<(), BuildError> {
    println!("cargo:rerun-if-changed={}", input);

    let content = fs::read_to_string(input)?;
    let testcases: TestCasesJson = serde_json::from_str(&content)?;

    // Extract base directory from input path (directory containing testcases.json)
    let base_dir = std::path::Path::new(input)
        .parent()
        .expect("Failed to get parent directory of testcases.json")
        .to_str()
        .expect("Failed to convert path to string");

    // Determine CSAF document type and constant name from version parameter
    let (csaf_doc_type, tests_const_name) = match csaf_version {
        CsafVersion::V2_0 => (
            quote! { crate::csaf2_0::schema::CommonSecurityAdvisoryFramework },
            Ident::new("TESTS_2_0", Span::call_site()),
        ),
        CsafVersion::V2_1 => (
            quote! { crate::csaf2_1::schema::CommonSecurityAdvisoryFramework },
            Ident::new("TESTS_2_1", Span::call_site()),
        ),
    };

    // Generate individual test struct definitions
    let mut test_struct_defs = Vec::new();
    let mut test_instances = Vec::new();
    let mut mandatory_tests = Vec::new();
    let mut optional_tests = Vec::new();
    let mut informative_tests = Vec::new();

    for test in &testcases.tests {
        // Convert "6.1.1" to "Test6_1_1" (camel case to avoid warnings)
        let struct_name = format!("Test{}", test.id.replace('.', "_"));
        let instance_name = format!("test_{}", test.id.replace('.', "_"));
        let test_id = &test.id;

        // Collect failure and valid test documents with their paths
        let mut failure_docs: Vec<(String, String)> = Vec::new(); // (case_num, path)
        let mut valid_docs: Vec<(String, String)> = Vec::new();

        for failure in &test.failures {
            if let Some(case_num) = extract_test_case_number(&failure.name) {
                failure_docs.push((case_num, failure.name.clone()));
            }
        }

        for valid in &test.valid {
            if let Some(case_num) = extract_test_case_number(&valid.name) {
                valid_docs.push((case_num, valid.name.clone()));
            }
        }

        // Generate struct definition for this specific test
        let struct_ident = Ident::new(&struct_name, Span::call_site());
        let instance_ident = Ident::new(&instance_name, Span::call_site());

        // Generate parameter names and types for the run method
        let mut param_names = Vec::new();
        let mut param_types = Vec::new();

        // Combine all docs with their case numbers
        let all_docs: Vec<_> = failure_docs.iter().chain(valid_docs.iter()).collect();

        for (case_num, _) in &all_docs {
            param_names.push(Ident::new(&format!("case_{}", case_num), Span::call_site()));
            param_types.push(quote! { Result<(), Vec<crate::validation::ValidationError>> });
        }

        // Generate tuples of (case_num, doc_expr, expected_param)
        let test_cases: Vec<_> = all_docs
            .iter()
            .enumerate()
            .map(|(idx, (case_num, path))| {
                let full_path = format!("{}/{}", base_dir, path);
                let param_name = &param_names[idx];
                quote! {
                    (
                        #case_num,
                        {
                            let path = #full_path;
                            let content = std::fs::read_to_string(path)
                                .unwrap_or_else(|e| panic!("Failed to load {} (case {}): {}", #path, #case_num, e));
                            serde_json::from_str::<#csaf_doc_type>(&content)
                                .unwrap_or_else(|e| panic!("Failed to parse {} (case {}): {}", #path, #case_num, e))
                        },
                        #param_name
                    )
                }
            })
            .collect();

        // Generate validator struct name
        let validator_name = format!("ValidatorFor{}", struct_name);
        let validator_ident = Ident::new(&validator_name, Span::call_site());

        // Generate the struct definition using the shared TestValidator trait
        let struct_def = quote! {
            #[derive(Debug, Clone, Copy)]
            pub struct #struct_ident<V>(std::marker::PhantomData<V>);

            impl<V> #struct_ident<V> {
                /// Test ID
                pub const ID: &'static str = #test_id;

                /// Create a new test instance
                pub const fn new() -> Self {
                    Self(std::marker::PhantomData)
                }

                /// Get the test ID
                pub fn id(&self) -> &'static str {
                    Self::ID
                }
            }

            impl<V: crate::test_validation::TestValidator<#csaf_doc_type> + Default> #struct_ident<V> {
                /// Validate a CSAF document using this test's validator.
                ///
                /// # Arguments
                /// * `doc` - The CSAF document to validate
                ///
                /// # Returns
                /// * `Ok(())` if validation passes
                /// * `Err(Vec<ValidationError>)` if validation fails
                pub fn validate(&self, doc: &#csaf_doc_type) -> Result<(), Vec<crate::validation::ValidationError>> {
                    let validator = V::default();
                    validator.validate(doc)
                }

                /// Run the test with expected results for each test case.
                ///
                /// The method automatically loads test documents from the file system and runs
                /// the validation function on each one, comparing actual vs expected results.
                ///
                /// # Arguments
                /// * One parameter per test case document with the expected result
                ///
                /// # Panics
                /// Panics if any test case fails to load, parse, or doesn't match the expected result
                ///
                pub fn expect(
                    &self,
                    #(#param_names: #param_types),*
                ) {
                    // Create test cases as tuples of (case_num, doc, expected)
                    let test_cases = vec![#(#test_cases),*];

                    // Create validator instance
                    let validator = V::default();

                    // Run test on each document and compare with expected result
                    for (case_num, doc, expected) in test_cases {
                        let actual = validator.validate(&doc);

                        // Use the extracted comparison function, panic on error
                        crate::test_result_comparison::compare_test_results(
                            &actual,
                            &expected,
                            Self::ID,
                            case_num
                        ).unwrap_or_else(|e| panic!("{}", e));
                    }
                }
            }

            /// Validator for test case #test_id
            ///
            /// Implement `TestValidator<#csaf_doc_type>` on this struct to provide validation logic.
            #[derive(Debug, Clone, Copy, Default)]
            pub struct #validator_ident;
        };

        test_struct_defs.push(struct_def);
        test_instances.push((instance_ident, struct_ident, validator_ident));

        match test.group.as_str() {
            "mandatory" => mandatory_tests.push(instance_name.clone()),
            "optional" => optional_tests.push(instance_name.clone()),
            "informative" => informative_tests.push(instance_name.clone()),
            _ => {},
        }
    }

    // Generate field definitions for TESTS constant (each test as a field with typed validator)
    let field_defs = test_instances
        .iter()
        .map(|(instance_name, struct_name, validator_name)| {
            quote! {
                pub #instance_name: #struct_name<#validator_name>
            }
        });

    // Generate field initializers for TESTS constant (with typed instances)
    let field_inits = test_instances
        .iter()
        .map(|(instance_name, struct_name, _validator_name)| {
            quote! {
                #instance_name: #struct_name::new()
            }
        });

    // Generate preset methods - collect the vecs for reuse
    let mandatory_refs: Vec<_> = mandatory_tests
        .iter()
        .map(|name| {
            let name_ident = Ident::new(name, Span::call_site());
            quote! { &#tests_const_name.#name_ident }
        })
        .collect();

    let optional_refs: Vec<_> = optional_tests
        .iter()
        .map(|name| {
            let name_ident = Ident::new(name, Span::call_site());
            quote! { &#tests_const_name.#name_ident }
        })
        .collect();

    let informative_refs: Vec<_> = informative_tests
        .iter()
        .map(|name| {
            let name_ident = Ident::new(name, Span::call_site());
            quote! { &#tests_const_name.#name_ident }
        })
        .collect();

    let tokens = quote! {
        #![doc = #GENERATED_CODE_HEADER]

        // Generate individual test structs
        #(#test_struct_defs)*

        /// Collection of all available test cases
        #[derive(Debug, Clone, Copy)]
        pub struct TestCases {
            #(#field_defs),*
        }

        impl TestCases {
            /// Create a new TestCases instance with all tests
            pub const fn new() -> Self {
                Self {
                    #(#field_inits),*
                }
            }

            /// Get all mandatory test IDs (basic preset)
            pub fn basic(&self) -> Vec<&'static str> {
                vec![#(#mandatory_refs.id()),*]
            }

            /// Get mandatory + optional test IDs (extended preset)
            pub fn extended(&self) -> Vec<&'static str> {
                let mut tests = self.basic();
                tests.extend(self.optional());
                tests
            }

            /// Get all test IDs (full preset)
            pub fn full(&self) -> Vec<&'static str> {
                let mut tests = self.extended();
                tests.extend(self.informative());
                tests
            }

            /// Get mandatory test IDs
            pub fn mandatory(&self) -> Vec<&'static str> {
                vec![#(#mandatory_refs.id()),*]
            }

            /// Get optional test IDs
            pub fn optional(&self) -> Vec<&'static str> {
                vec![#(#optional_refs.id()),*]
            }

            /// Get informative test IDs
            pub fn informative(&self) -> Vec<&'static str> {
                vec![#(#informative_refs.id()),*]
            }
        }

        /// Global constant instance of all test cases
        pub const #tests_const_name: TestCases = TestCases::new();

        /// Get all mandatory tests as IDs
        pub fn mandatory_tests() -> Vec<&'static str> {
            vec![#(#mandatory_refs.id()),*]
        }

        /// Get all optional tests as IDs
        pub fn optional_tests() -> Vec<&'static str> {
            vec![#(#optional_refs.id()),*]
        }

        /// Get all informative tests as IDs
        pub fn informative_tests() -> Vec<&'static str> {
            vec![#(#informative_refs.id()),*]
        }
    };

    let mut file: syn::File = syn::parse2(tokens)?;
    add_ignore_rustfmt(&mut file);
    add_ignore_clippy(&mut file);

    let code = prettyplease::unparse(&file);

    let out_path = Path::new("src").join(output);
    fs::write(&out_path, code)?;

    Ok(())
}
