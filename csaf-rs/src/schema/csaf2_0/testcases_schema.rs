/*!
 * This file is automatically generated by build.rs.
 * Do not edit manually!
 */
#![allow(clippy::all)]
#![cfg_attr(any(), rustfmt::skip)]
/// Error types.
pub mod error {
    /// Error from a `TryFrom` or `FromStr` implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///Contains information about a single test file.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "File information",
///  "description": "Contains information about a single test file.",
///  "type": "object",
///  "required": [
///    "name",
///    "valid"
///  ],
///  "properties": {
///    "name": {
///      "title": "Name of the test file",
///      "description": "Contains the filename and path relative to the JSON that includes this object.",
///      "type": "string",
///      "pattern": "^.+\\.json$"
///    },
///    "valid": {
///      "title": "Evaluation result",
///      "description": "States whether the test file is valid according to the CSAF standard.",
///      "type": "boolean"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct FileT {
    ///Contains the filename and path relative to the JSON that includes this object.
    pub name: NameOfTheTestFile,
    ///States whether the test file is valid according to the CSAF standard.
    pub valid: bool,
}
impl ::std::convert::From<&FileT> for FileT {
    fn from(value: &FileT) -> Self {
        value.clone()
    }
}
impl FileT {
    pub fn builder() -> builder::FileT {
        Default::default()
    }
}
///Contains the URL of the JSON schema for test data which the document promises to be valid for.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "JSON schema",
///  "description": "Contains the URL of the JSON schema for test data which the document promises to be valid for.",
///  "type": "string",
///  "format": "uri",
///  "enum": [
///    "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum JsonSchema {
    #[serde(
        rename = "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json"
    )]
    HttpsRawGithubusercontentComOasisTcsCsafMasterCsaf20TestValidatorTestcasesJsonSchemaJson,
}
impl ::std::convert::From<&Self> for JsonSchema {
    fn from(value: &JsonSchema) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::HttpsRawGithubusercontentComOasisTcsCsafMasterCsaf20TestValidatorTestcasesJsonSchemaJson => {
                f.write_str(
                    "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json",
                )
            }
        }
    }
}
impl ::std::str::FromStr for JsonSchema {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json" => {
                Ok(
                    Self::HttpsRawGithubusercontentComOasisTcsCsafMasterCsaf20TestValidatorTestcasesJsonSchemaJson,
                )
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonSchema {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonSchema {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonSchema {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///Contains the filename and path relative to the JSON that includes this object.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Name of the test file",
///  "description": "Contains the filename and path relative to the JSON that includes this object.",
///  "type": "string",
///  "pattern": "^.+\\.json$"
///}
/// ```
/// </details>
#[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct NameOfTheTestFile(::std::string::String);
impl ::std::ops::Deref for NameOfTheTestFile {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<NameOfTheTestFile> for ::std::string::String {
    fn from(value: NameOfTheTestFile) -> Self {
        value.0
    }
}
impl ::std::convert::From<&NameOfTheTestFile> for NameOfTheTestFile {
    fn from(value: &NameOfTheTestFile) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NameOfTheTestFile {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(||
        { ::regress::Regex::new("^.+\\.json$").unwrap() });
        if PATTERN.find(value).is_none() {
            return Err("doesn't match pattern \"^.+\\.json$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for NameOfTheTestFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NameOfTheTestFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NameOfTheTestFile {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for NameOfTheTestFile {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
///Contains the section number of the test in the specification.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Number of the test",
///  "description": "Contains the section number of the test in the specification.",
///  "type": "string",
///  "pattern": "^6\\.(([1-3]\\.[1-9])|([12]\\.1[0-9])|(3\\.1[01])|([12]\\.20)|(1\\.2[1-68-9])|(1\\.27\\.([1-9]|10|11))|(1\\.3[0-3]))$"
///}
/// ```
/// </details>
#[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct NumberOfTheTest(::std::string::String);
impl ::std::ops::Deref for NumberOfTheTest {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<NumberOfTheTest> for ::std::string::String {
    fn from(value: NumberOfTheTest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&NumberOfTheTest> for NumberOfTheTest {
    fn from(value: &NumberOfTheTest) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberOfTheTest {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(||
        {
            ::regress::Regex::new(
                    "^6\\.(([1-3]\\.[1-9])|([12]\\.1[0-9])|(3\\.1[01])|([12]\\.20)|(1\\.2[1-68-9])|(1\\.27\\.([1-9]|10|11))|(1\\.3[0-3]))$",
                )
                .unwrap()
        });
        if PATTERN.find(value).is_none() {
            return Err(
                "doesn't match pattern \"^6\\.(([1-3]\\.[1-9])|([12]\\.1[0-9])|(3\\.1[01])|([12]\\.20)|(1\\.2[1-68-9])|(1\\.27\\.([1-9]|10|11))|(1\\.3[0-3]))$\""
                    .into(),
            );
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for NumberOfTheTest {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberOfTheTest {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberOfTheTest {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for NumberOfTheTest {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
///Representation of the data provided for test cases from section 6 of the specification.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "$id": "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json",
///  "title": "Test cases for CSAF",
///  "description": "Representation of the data provided for test cases from section 6 of the specification.",
///  "type": "object",
///  "required": [
///    "$schema",
///    "tests",
///    "testschema_version"
///  ],
///  "properties": {
///    "$schema": {
///      "title": "JSON schema",
///      "description": "Contains the URL of the JSON schema for test data which the document promises to be valid for.",
///      "type": "string",
///      "format": "uri",
///      "enum": [
///        "https://raw.githubusercontent.com/oasis-tcs/csaf/master/csaf_2.0/test/validator/testcases_json_schema.json"
///      ]
///    },
///    "tests": {
///      "title": "List of tests",
///      "description": "Contains a list of test data.",
///      "type": "array",
///      "items": {
///        "$ref": "#/$defs/test_t"
///      },
///      "minItems": 1,
///      "uniqueItems": true
///    },
///    "testschema_version": {
///      "title": "Test schema version",
///      "description": "Contains the current version of this schema",
///      "type": "string",
///      "enum": [
///        "2.0"
///      ]
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct TestCasesForCsaf {
    ///Contains the URL of the JSON schema for test data which the document promises to be valid for.
    #[serde(rename = "$schema")]
    pub schema: JsonSchema,
    ///Contains a list of test data.
    pub tests: Vec<TestT>,
    ///Contains the current version of this schema
    pub testschema_version: TestSchemaVersion,
}
impl ::std::convert::From<&TestCasesForCsaf> for TestCasesForCsaf {
    fn from(value: &TestCasesForCsaf) -> Self {
        value.clone()
    }
}
impl TestCasesForCsaf {
    pub fn builder() -> builder::TestCasesForCsaf {
        Default::default()
    }
}
///Contains the name of the group the test belongs to.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Test group",
///  "description": "Contains the name of the group the test belongs to.",
///  "type": "string",
///  "enum": [
///    "mandatory",
///    "informative",
///    "optional"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum TestGroup {
    #[serde(rename = "mandatory")]
    Mandatory,
    #[serde(rename = "informative")]
    Informative,
    #[serde(rename = "optional")]
    Optional,
}
impl ::std::convert::From<&Self> for TestGroup {
    fn from(value: &TestGroup) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TestGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Mandatory => f.write_str("mandatory"),
            Self::Informative => f.write_str("informative"),
            Self::Optional => f.write_str("optional"),
        }
    }
}
impl ::std::str::FromStr for TestGroup {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "mandatory" => Ok(Self::Mandatory),
            "informative" => Ok(Self::Informative),
            "optional" => Ok(Self::Optional),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TestGroup {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TestGroup {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TestGroup {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///Contains the current version of this schema
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Test schema version",
///  "description": "Contains the current version of this schema",
///  "type": "string",
///  "enum": [
///    "2.0"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum TestSchemaVersion {
    #[serde(rename = "2.0")]
    X20,
}
impl ::std::convert::From<&Self> for TestSchemaVersion {
    fn from(value: &TestSchemaVersion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TestSchemaVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::X20 => f.write_str("2.0"),
        }
    }
}
impl ::std::str::FromStr for TestSchemaVersion {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::X20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TestSchemaVersion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TestSchemaVersion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TestSchemaVersion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///Contains test data for a single test.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "Test",
///  "description": "Contains test data for a single test.",
///  "type": "object",
///  "required": [
///    "failures",
///    "group",
///    "id"
///  ],
///  "properties": {
///    "failures": {
///      "title": "List of failing examples",
///      "description": "Contains a list of files of examples that fail that specific test.",
///      "type": "array",
///      "items": {
///        "$ref": "#/$defs/file_t"
///      },
///      "minItems": 1,
///      "uniqueItems": true
///    },
///    "group": {
///      "title": "Test group",
///      "description": "Contains the name of the group the test belongs to.",
///      "type": "string",
///      "enum": [
///        "mandatory",
///        "informative",
///        "optional"
///      ]
///    },
///    "id": {
///      "title": "Number of the test",
///      "description": "Contains the section number of the test in the specification.",
///      "type": "string",
///      "pattern": "^6\\.(([1-3]\\.[1-9])|([12]\\.1[0-9])|(3\\.1[01])|([12]\\.20)|(1\\.2[1-68-9])|(1\\.27\\.([1-9]|10|11))|(1\\.3[0-3]))$"
///    },
///    "valid": {
///      "title": "List of valid examples",
///      "description": "Contains a list of files of examples that pass that specific test.",
///      "type": "array",
///      "items": {
///        "$ref": "#/$defs/file_t"
///      },
///      "minItems": 1,
///      "uniqueItems": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct TestT {
    ///Contains a list of files of examples that fail that specific test.
    pub failures: Vec<FileT>,
    ///Contains the name of the group the test belongs to.
    pub group: TestGroup,
    ///Contains the section number of the test in the specification.
    pub id: NumberOfTheTest,
    ///Contains a list of files of examples that pass that specific test.
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub valid: ::std::option::Option<Vec<FileT>>,
}
impl ::std::convert::From<&TestT> for TestT {
    fn from(value: &TestT) -> Self {
        value.clone()
    }
}
impl TestT {
    pub fn builder() -> builder::TestT {
        Default::default()
    }
}
/// Types for composing complex structures.
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct FileT {
        name: ::std::result::Result<super::NameOfTheTestFile, ::std::string::String>,
        valid: ::std::result::Result<bool, ::std::string::String>,
    }
    impl ::std::default::Default for FileT {
        fn default() -> Self {
            Self {
                name: Err("no value supplied for name".to_string()),
                valid: Err("no value supplied for valid".to_string()),
            }
        }
    }
    impl FileT {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::NameOfTheTestFile>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn valid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<bool>,
            T::Error: ::std::fmt::Display,
        {
            self.valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<FileT> for super::FileT {
        type Error = super::error::ConversionError;
        fn try_from(
            value: FileT,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                name: value.name?,
                valid: value.valid?,
            })
        }
    }
    impl ::std::convert::From<super::FileT> for FileT {
        fn from(value: super::FileT) -> Self {
            Self {
                name: Ok(value.name),
                valid: Ok(value.valid),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TestCasesForCsaf {
        schema: ::std::result::Result<super::JsonSchema, ::std::string::String>,
        tests: ::std::result::Result<Vec<super::TestT>, ::std::string::String>,
        testschema_version: ::std::result::Result<
            super::TestSchemaVersion,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TestCasesForCsaf {
        fn default() -> Self {
            Self {
                schema: Err("no value supplied for schema".to_string()),
                tests: Err("no value supplied for tests".to_string()),
                testschema_version: Err(
                    "no value supplied for testschema_version".to_string(),
                ),
            }
        }
    }
    impl TestCasesForCsaf {
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::JsonSchema>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for schema: {}", e)
                });
            self
        }
        pub fn tests<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<Vec<super::TestT>>,
            T::Error: ::std::fmt::Display,
        {
            self.tests = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for tests: {}", e)
                });
            self
        }
        pub fn testschema_version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TestSchemaVersion>,
            T::Error: ::std::fmt::Display,
        {
            self.testschema_version = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for testschema_version: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<TestCasesForCsaf> for super::TestCasesForCsaf {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TestCasesForCsaf,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                schema: value.schema?,
                tests: value.tests?,
                testschema_version: value.testschema_version?,
            })
        }
    }
    impl ::std::convert::From<super::TestCasesForCsaf> for TestCasesForCsaf {
        fn from(value: super::TestCasesForCsaf) -> Self {
            Self {
                schema: Ok(value.schema),
                tests: Ok(value.tests),
                testschema_version: Ok(value.testschema_version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TestT {
        failures: ::std::result::Result<Vec<super::FileT>, ::std::string::String>,
        group: ::std::result::Result<super::TestGroup, ::std::string::String>,
        id: ::std::result::Result<super::NumberOfTheTest, ::std::string::String>,
        valid: ::std::result::Result<
            ::std::option::Option<Vec<super::FileT>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TestT {
        fn default() -> Self {
            Self {
                failures: Err("no value supplied for failures".to_string()),
                group: Err("no value supplied for group".to_string()),
                id: Err("no value supplied for id".to_string()),
                valid: Ok(Default::default()),
            }
        }
    }
    impl TestT {
        pub fn failures<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<Vec<super::FileT>>,
            T::Error: ::std::fmt::Display,
        {
            self.failures = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for failures: {}", e)
                });
            self
        }
        pub fn group<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TestGroup>,
            T::Error: ::std::fmt::Display,
        {
            self.group = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for group: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::NumberOfTheTest>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn valid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<Vec<super::FileT>>>,
            T::Error: ::std::fmt::Display,
        {
            self.valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<TestT> for super::TestT {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TestT,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                failures: value.failures?,
                group: value.group?,
                id: value.id?,
                valid: value.valid?,
            })
        }
    }
    impl ::std::convert::From<super::TestT> for TestT {
        fn from(value: super::TestT) -> Self {
            Self {
                failures: Ok(value.failures),
                group: Ok(value.group),
                id: Ok(value.id),
                valid: Ok(value.valid),
            }
        }
    }
}
