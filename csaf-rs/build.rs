use quote::quote;
use serde_json::Value;
use std::path::Path;
use std::string::ToString;
use std::{fs, io};
use thiserror::Error;
use typify::{TypeSpace, TypeSpaceSettings};

#[derive(Error, Debug)]
pub enum BuildError {
    #[error("I/O error")]
    IoError(#[from] io::Error),
    #[error("JSON schema error")]
    SchemaError(#[from] typify::Error),
    #[error("Rust syntax error")]
    SyntaxError(#[from] syn::Error),
    #[error("JSON parsing error")]
    JsonError(#[from] serde_json::Error),
    #[error("other error")]
    Other,
}

fn main() -> Result<(), BuildError> {
    println!("cargo:rerun-if-changed=build.rs");

    // All schema files for change watching
    let schema_configs = [
        (
            "assets/decision_point_json_schema.json",
            "csaf2_1/ssvc_dp.generated.rs",
            None,
        ),
        (
            "assets/decision_point_selection_list_json_schema.json",
            "csaf2_1/ssvc_dp_selection_list.generated.rs",
            None,
        ),
    ];

    // Register watching for all inputs
    for (input, _, _) in &schema_configs {
        println!("cargo:rerun-if-changed={input}");
    }

    // Execute all listed schema builds
    for (input, output, schema_patch) in &schema_configs {
        build(input, output, schema_patch)?;
    }

    generate_language_subtags()?;

    Ok(())
}

pub static GENERATED_CODE_HEADER: &str = "
 * This file is automatically generated by build.rs.
 * Do not edit manually!
 ";

fn add_ignore_rustfmt(file: &mut syn::File) {
    let doc_attr = syn::parse_quote! { #![cfg_attr(any(), rustfmt::skip)] };
    file.attrs.insert(0, doc_attr);
}

fn add_ignore_clippy(file: &mut syn::File) {
    let doc_attr = syn::parse_quote! { #![allow(clippy::all)] };
    file.attrs.insert(0, doc_attr);
}

fn build(input: &str, output: &str, schema_patch: &Option<&dyn Fn(&mut Value)>) -> Result<(), BuildError> {
    let content = fs::read_to_string(input)?;
    let mut schema_value = serde_json::from_str(&content)?;
    // Execute a schema patch function, if provided.
    if let Some(patch_fn) = schema_patch {
        patch_fn(&mut schema_value);
    }
    let schema: schemars::schema::RootSchema = serde_json::from_value(schema_value)?;

    let mut type_space = TypeSpace::new(
        TypeSpaceSettings::default()
            .with_struct_builder(true)
            .with_derive("PartialEq".into())
            .with_derive("Eq".into()),
    );
    type_space.add_root_schema(schema)?;

    // Convert the TypeSpace token stream into a syn::File so we can inject a file-level doc attribute
    let mut file = syn::parse2::<syn::File>(type_space.to_stream())?;

    add_ignore_rustfmt(&mut file);
    add_ignore_clippy(&mut file);
    // Parse the GENERATED_CODE_HEADER as a doc attribute
    let doc_attr = syn::parse_quote! { #![doc = #GENERATED_CODE_HEADER] };
    file.attrs.insert(0, doc_attr);

    // Unparse the modified syn::File into Rust source code
    let content = prettyplease::unparse(&file);

    let mut out_file = Path::new("src").to_path_buf();
    out_file.push(output);
    Ok(fs::write(out_file, content)?)
}

/// Compile-time-embedded language-subtag-registry.txt
const LANGUAGE_REGISTRY: &str = include_str!("assets/language-subtag-registry.txt");

/// Generates the language subtags array from the build-embedded text file.
fn generate_language_subtags() -> Result<(), BuildError> {
    let mut subtags = Vec::new();
    let mut current_entry_type = None;

    for line in LANGUAGE_REGISTRY.lines() {
        let line = line.trim();

        if line.is_empty() || line.starts_with("%%") {
            current_entry_type = None;
            continue;
        }

        if let Some(type_value) = line.strip_prefix("Type: ") {
            current_entry_type = Some(type_value.to_string());
            continue;
        }

        if let Some(ref entry_type) = current_entry_type
            && entry_type == "language"
            && let Some(subtag) = line.strip_prefix("Subtag: ")
        {
            subtags.push(subtag.to_lowercase().to_string());
        }
    }

    subtags.sort_unstable();

    let subtags_iter = subtags.iter().map(|s| s.as_str());

    let tokens = quote! {
        #![doc = #GENERATED_CODE_HEADER]
        pub static LANGUAGE_SUBTAGS_ARRAY: &[&str] = &[
            #(#subtags_iter),*
        ];

        /// Checks if a given subtag is a valid language subtag.
        /// Lower cases the input before checking.
        pub fn is_valid_language_subtag(subtag: &str) -> bool {
            let sub = &subtag.to_lowercase();
            LANGUAGE_SUBTAGS_ARRAY.binary_search(&sub.as_str()).is_ok()
        }
    };

    let mut file: syn::File = syn::parse2(tokens)?;
    add_ignore_rustfmt(&mut file);
    add_ignore_clippy(&mut file);

    // Pretty-print the generated code.
    let code = prettyplease::unparse(&file);

    let out_path = Path::new("src").join("generated").join("language_subtags.rs");
    fs::write(&out_path, code)?;

    println!("cargo:rerun-if-changed=../assets/language-subtag-registry.txt");
    Ok(())
}
